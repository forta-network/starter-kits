import asyncio
from web3 import Web3, AsyncWeb3
from os import environ
from forta_bot import scan_ethereum, TransactionEvent, BlockEvent, get_chain_id, run_health_check, Finding, FindingSeverity, FindingType, EntityType
from datetime import datetime
from typing import List, Dict, Tuple
import time
import json
from ratelimiter import RateLimiter
from bot_alert_rate import calculate_alert_rate, ScanCountType
from expiring_dict import ExpiringDict

import aiohttp

from logger import logger
from storage import get_secrets
LABEL_CACHE = ExpiringDict(ttl=86_400)
ADDRESS_QUEUE = set()
BOT_ID = "0x0e82982faa7878af3fad8ddf5042762a3b78d8949da2e301f1adfedc973f25ea"
 
SECRETS_JSON = None
CHAIN_ID = -1

async def initialize():
    global CHAIN_ID
    global SECRETS_JSON

    SECRETS_JSON = await get_secrets()
    environ["ZETTABLOCK_API_KEY"] = SECRETS_JSON['apiKeys']['ZETTABLOCK']

    try:
        if CHAIN_ID == -1:
            chain_id_temp = environ.get('FORTA_CHAIN_ID')
            if chain_id_temp is None:
                CHAIN_ID = get_chain_id()
            else:
                CHAIN_ID = int(chain_id_temp)        
    except Exception as e:
        raise e
    

def get_api_key():
    global SECRETS_JSON
    global CHAIN_ID

    if CHAIN_ID == 1:
        return SECRETS_JSON['apiKeys']['ETHERSCAN_TOKEN']
    elif CHAIN_ID == 137:
        return SECRETS_JSON['apiKeys']['POLYGONSCAN_TOKEN']
    elif CHAIN_ID == 56:
        return SECRETS_JSON['apiKeys']['BSCSCAN_TOKEN']
    elif CHAIN_ID == 42161:
        return SECRETS_JSON['apiKeys']['ARBISCAN_TOKEN']
    elif CHAIN_ID == 10:
        return SECRETS_JSON['apiKeys']['OPTIMISTICSCAN_TOKEN']
    elif CHAIN_ID == 250:
        return SECRETS_JSON['apiKeys']['FTMSCAN_TOKEN']
    elif CHAIN_ID == 43114:
        return SECRETS_JSON['apiKeys']['SNOWTRACE_TOKEN']
    
    raise Exception("Chain ID not supported")
    

@RateLimiter(max_calls=1, period=1)
async def get_labels() -> dict:
    global CHAIN_ID
    global ADDRESS_QUEUE

    address_labels = dict()
    no_label_addresses = set() 
    count = 0
    for address in ADDRESS_QUEUE.copy():
        ADDRESS_QUEUE.remove(address)

        if address in LABEL_CACHE:
            address_labels[address] = LABEL_CACHE[address]
        else:
            no_label_addresses.add(address)
            count+=1
            if count > 99:
                break

    try:
        addresses_str = ','.join(no_label_addresses)
        labels_url = f"https://api-metadata.etherscan.io/v1/api.ashx?module=nametag&action=getaddresstag&address={addresses_str}&tag=trusted&apikey={get_api_key()}"

        success = False
        count = 0
        while not success:
            async with aiohttp.ClientSession() as session:
                async with session.get(labels_url) as res:
                    if res.status == 200:
                        try:
                            # Attempt to parse the response as JSON regardless of the Content-Type
                            json_data = await res.json(content_type=None)
                            success = True
                            if isinstance(json_data["result"], list):
                                for result in json_data["result"]:
                                    if len(result["labels"]):
                                        address_labels[result["address"]] = result["nametag"] 
                                        LABEL_CACHE[result["address"]] = result["nametag"]
                                for address, labels in address_labels.items():
                                    logger.info(f"Labels for address {address}: {labels}")   
                                return address_labels
                        except json.JSONDecodeError:
                            raise Exception("Failed to decode JSON response")
                            
                    else:
                        logger.info(f"Error getting labels on etherscan: {res.status} {res.content}")
                        count += 1
                        if count > 10:
                            
                            break
                        time.sleep(1)
    except Exception as e:
        logger.info(f"Error getting labels on etherscan: {e}")
        
        
    return address_labels


async def handle_transaction(transaction_event: TransactionEvent, web3: AsyncWeb3.AsyncHTTPProvider) -> list:

    global CHAIN_ID
    global ADDRESS_QUEUE

    if transaction_event.from_ not in LABEL_CACHE and transaction_event.from_ is not None:
        ADDRESS_QUEUE.add(transaction_event.from_.lower())

    return []


async def provide_handle_block(w3, block_event: BlockEvent):    
    findings = []
    dt = datetime.fromtimestamp(block_event.block.timestamp)
    if dt.minute == 0 or dt.minute == 30 or dt.minute == 15 or dt.minute == 45:
        attacker_labels = await get_labels() # address-> label
        for address, label in attacker_labels.items():
            if label is not None:
                if 'phish' in label.lower() or 'scam' in label.lower() or 'exploit' in label.lower() or 'attack' in label.lower():
                    alert_id = "EXPLOITER-ADDR-TX"

                    exploiter_address = address

                    description_msg = (
                        f"Transaction involving an exploiter address: {exploiter_address}"
                    )

                    if label:
                        description_msg += f" with label: {label}"

                    labels = [
                        {
                            "entity": exploiter_address,
                            "entity_type": EntityType.Address,
                            "label": "attacker",
                            "confidence": 1,
                        }
                    ]

                    source = {
                        'chains': [{'chainId': CHAIN_ID}],
                        'blocks': [{'chainId': CHAIN_ID, 'hash': block_event.block_hash, 'number': block_event.block_number}]
                    }

                    """
                    chain_id: int
                    hash: str
                    number: int
                    """

                    metadata = {
                        "exploiter_address": exploiter_address,
                        "blocklist_label": label,
                        "labels_source": 'etherscan'
                    }

                    if CHAIN_ID not in [43114, 10, 250]:
                        anomaly_score = round(
                            calculate_alert_rate(
                                CHAIN_ID, BOT_ID, alert_id, ScanCountType.TX_COUNT
                            ),
                            6,
                        )

                        metadata["anomaly_score"] = str(anomaly_score)

                    finding = Finding(
                        {
                            "name": "Exploiter Address",
                            "description": description_msg,
                            "alert_id": alert_id,
                            "severity": FindingSeverity.High,
                            "type": FindingType.Suspicious,
                            "metadata": metadata,
                            "source": source,
                            "labels": labels,
                        }
                    )
                    findings.append(finding)

    return findings


async def handle_block(block_event: BlockEvent, web3: AsyncWeb3.AsyncHTTPProvider) -> list:

    return await provide_handle_block(web3, block_event)

async def main():
    await initialize()
    
    await asyncio.gather(
        scan_ethereum({
            'rpc_url': "https://eth-mainnet.g.alchemy.com/v2",
            'rpc_key_id': "420b57cc-c2cc-442c-8fd8-901d70a835a5",
            'local_rpc_url': "1",
            'handle_transaction': handle_transaction,
            'handle_block': handle_block
        }),
        run_health_check()
    )

if __name__ == "__main__":
    asyncio.run(main())