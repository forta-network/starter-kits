from os import environ
import forta_agent
from forta_agent import Finding, FindingType, FindingSeverity, get_json_rpc_url, EntityType
from web3 import Web3
from datetime import datetime
from typing import List, Dict, Tuple
import time
import json
from ratelimiter import RateLimiter
from bot_alert_rate import calculate_alert_rate, ScanCountType
from expiring_dict import ExpiringDict

import requests

from src.logger import logger
from src.storage import get_secrets

web3 = Web3(Web3.HTTPProvider(get_json_rpc_url()))
LABEL_CACHE = ExpiringDict(ttl=86_400)
ADDRESS_QUEUE = set()
BOT_ID = "0x0e82982faa7878af3fad8ddf5042762a3b78d8949da2e301f1adfedc973f25ea"
 
SECRETS_JSON = get_secrets()
CHAIN_ID = -1

web3 = Web3(Web3.HTTPProvider(get_json_rpc_url()))

def initialize():
    global CHAIN_ID

    environ["ZETTABLOCK_API_KEY"] = SECRETS_JSON['apiKeys']['ZETTABLOCK']

    try:
        if CHAIN_ID == -1:
            chain_id_temp = environ.get('FORTA_CHAIN_ID')
            if chain_id_temp is None:
                CHAIN_ID = web3.eth.chain_id
            else:
                CHAIN_ID = int(chain_id_temp)        
    except Exception as e:
        raise e
    

def get_api_key():
    global SECRETS_JSON
    global CHAIN_ID

    if CHAIN_ID == 1:
        return SECRETS_JSON['apiKeys']['ETHERSCAN_TOKEN']
    elif CHAIN_ID == 137:
        return SECRETS_JSON['apiKeys']['POLYGONSCAN_TOKEN']
    elif CHAIN_ID == 56:
        return SECRETS_JSON['apiKeys']['BSCSCAN_TOKEN']
    elif CHAIN_ID == 42161:
        return SECRETS_JSON['apiKeys']['ARBISCAN_TOKEN']
    elif CHAIN_ID == 10:
        return SECRETS_JSON['apiKeys']['OPTIMISTICSCAN_TOKEN']
    elif CHAIN_ID == 250:
        return SECRETS_JSON['apiKeys']['FTMSCAN_TOKEN']
    elif CHAIN_ID == 43114:
        return SECRETS_JSON['apiKeys']['SNOWTRACE_TOKEN']
    
    raise Exception("Chain ID not supported")
    

@RateLimiter(max_calls=1, period=1)
def get_labels() -> dict:
    global CHAIN_ID
    global ADDRESS_QUEUE

    address_labels = dict()
    no_label_addresses = set() 
    count = 0
    for address in ADDRESS_QUEUE.copy():
        ADDRESS_QUEUE.remove(address)

        if address in LABEL_CACHE:
            address_labels[address] = LABEL_CACHE[address]
        else:
            no_label_addresses.add(address)
            count+=1
            if count > 99:
                break

    try:
        addresses_str = ','.join(no_label_addresses)
        labels_url = f"https://api-metadata.etherscan.io/v1/api.ashx?module=nametag&action=getaddresstag&address={addresses_str}&tag=trusted&apikey={get_api_key()}"

        success = False
        count = 0
        while not success:
            data = requests.get(labels_url)
            if data.status_code == 200:
                json_data = json.loads(data.content)
                success = True
                for result in json_data["result"]:
                    if len(result["labels"]):
                        address_labels[result["address"]] = result["nametag"] 
                        LABEL_CACHE[result["address"]] = result["nametag"]
                for address, labels in address_labels.items():
                    logger.info(f"Labels for address {address}: {', '.join(labels)}")   
                return address_labels
            else:
                logger.info(f"Error getting labels on etherscan: {data.status_code} {data.content}")
                count += 1
                if count > 10:
                    
                    break
                time.sleep(1)
    except Exception as e:
        logger.info(f"Error getting labels on etherscan: {e}")
        
        
    return address_labels




def handle_transaction(transaction_event: forta_agent.transaction_event.TransactionEvent) -> list:

    global CHAIN_ID
    global ADDRESS_QUEUE

    if transaction_event.from_ not in LABEL_CACHE and transaction_event.from_ is not None:
        ADDRESS_QUEUE.add(transaction_event.from_.lower())

    return []


def provide_handle_block():
    def handle_block(block_event: forta_agent.block_event.BlockEvent) -> list:
        findings = []
        dt = datetime.fromtimestamp(block_event.block.timestamp)
        if dt.minute == 0 or dt.minute == 30 or dt.minute == 15 or dt.minute == 45:
            attacker_labels = get_labels() # address-> label
            for address, label in attacker_labels.items():
                if label is not None:
                    if 'phish' in label.lower() or 'scam' in label.lower() or 'exploit' in label.lower() or 'attack' in label.lower():
                        alert_id = "EXPLOITER-ADDR-TX"

                        exploiter_address = address

                        description_msg = (
                            f"Transaction involving an exploiter address: {exploiter_address}"
                        )

                        if label:
                            description_msg += f" with label: {label}"

                        labels = [
                            {
                                "entity": exploiter_address,
                                "entity_type": EntityType.Address,
                                "label": "attacker",
                                "confidence": 1,
                            }
                        ]

                        metadata = {
                            "exploiter_address": exploiter_address,
                            "blocklist_label": label,
                            "labels_source": 'etherscan'
                        }

                        if CHAIN_ID not in [43114, 10, 250]:
                            anomaly_score = round(
                                calculate_alert_rate(
                                    CHAIN_ID, BOT_ID, alert_id, ScanCountType.TX_COUNT
                                ),
                                6,
                            )

                            metadata["anomaly_score"] = anomaly_score

                        finding = Finding(
                            {
                                "name": "Exploiter Address",
                                "description": description_msg,
                                "alert_id": alert_id,
                                "severity": FindingSeverity.High,
                                "type": FindingType.Suspicious,
                                "metadata": metadata,
                                "labels": labels,
                            }
                        )
                        findings.append(finding)

        return findings

    return handle_block


real_handle_block = provide_handle_block()


def handle_block(block_event: forta_agent.block_event.BlockEvent) -> list:
    return real_handle_block(block_event)