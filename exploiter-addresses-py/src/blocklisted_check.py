from datetime import datetime
from typing import List, Dict, Tuple

from bot_alert_rate import calculate_alert_rate, ScanCountType
from expiring_dict import ExpiringDict
from forta_agent import (
    get_json_rpc_url,
    EntityType,
    Finding,
    FindingType,
    FindingSeverity,
)
import requests
from web3 import Web3

from .constants import CHAIN_SOURCE_IDS_MAPPING, BOT_ID
from .logger import logger

web3 = Web3(Web3.HTTPProvider(get_json_rpc_url()))
BLOCKLISTED = ExpiringDict(ttl=86_400)


def get_blocklisted_addresses(address) -> Tuple[str, str]:
    metadata = None, None
    if address in BLOCKLISTED:
        return BLOCKLISTED[address]

    for _, source_ids in CHAIN_SOURCE_IDS_MAPPING.items():
        for source_id in source_ids:
            labels_url = f"https://api.forta.network/labels/state?entities={address}&sourceIds={source_id}&labels=*xploit*,*hish*,*heist*&limit=1"
            try:
                result = requests.get(labels_url).json()

                if result["events"] is not None and len(result["events"]) > 0:
                    label = result["events"][0]
                    data = label["label"]
                    address = data["entity"]
                    wallet_tag = data["label"]
                    metadata = (wallet_tag, source_id)
                BLOCKLISTED[address] = metadata

            except Exception as err:
                logger.error(f"Error obtaining malicious accounts: {err}")
    return metadata


def alert_count(chain_id) -> int:
    alert_stats_url = (
        f"https://api.forta.network/stats/bot/{BOT_ID}/alerts?chainId={chain_id}"
    )
    alert_count = 0
    try:
        result = requests.get(alert_stats_url).json()
        alert_count = result["total"]["count"]
    except Exception as err:
        logger.error(f"Error obtaining alert counts: {err}")

    return alert_count


def provide_handle_transaction(w3):
    def handle_transaction(transaction_event):
        findings = []

        date_time = datetime.now()
        date_hour = date_time.strftime("%d/%m/%Y %H:00:00")
        addresses = [transaction_event.to, transaction_event.from_]

        blocklisted_addresses = {a: get_blocklisted_addresses(a) for a in addresses}

        for address, metadata in blocklisted_addresses.items():
            wallet_tag, data_source = metadata
            if wallet_tag is not None:
                alert_id = "EXPLOITER-ADDR-TX"
                anomaly_score = round(
                    calculate_alert_rate(
                        w3.eth.chain_id, BOT_ID, alert_id, ScanCountType.TX_COUNT
                    ),
                    6,
                )
                exploiter_address = address

                description_msg = (
                    f"Transaction involving an exploiter address: {exploiter_address}"
                )

                if wallet_tag:
                    description_msg += f" with wallet tag: {wallet_tag}"

                labels = [
                    {
                        "entity": transaction_event.hash,
                        "entity_type": EntityType.Transaction,
                        "label": "attacker",
                        "confidence": 1,
                    }
                ]
                finding = Finding(
                    {
                        "name": "Exploiter Address",
                        "description": description_msg,
                        "alert_id": alert_id,
                        "severity": FindingSeverity.High,
                        "type": FindingType.Suspicious,
                        "metadata": {
                            "exploiter_address": exploiter_address,
                            "wallet_tag": wallet_tag,
                            "labels_source": data_source,
                            "anomaly_score": anomaly_score,
                        },
                        "labels": labels,
                    }
                )
                findings.append(finding)

        return findings

    return handle_transaction


real_handle_transaction = provide_handle_transaction(web3)


def handle_transaction(transaction_event):
    return real_handle_transaction(transaction_event)
